"use client";

import { useState, useEffect, useRef } from "react";
import { useLocalParticipant, useRoomContext } from "@livekit/components-react";
import { Track, VideoPresets } from "livekit-client";
import { Mic, MicOff, Video, VideoOff, Monitor, MessageSquare, PhoneOff, Pencil, Square } from "lucide-react";
import { cn } from "@/lib/utils";
import { useRouter } from "next/navigation";

interface CustomControlBarProps {
  isTutor?: boolean;
  showWhiteboard?: boolean;
  showAnnotations?: boolean;
  showChat?: boolean;
  onToggleWhiteboard?: () => void;
  onToggleAnnotations?: () => void;
  onToggleChat?: () => void;
}

export default function CustomControlBar({ 
  isTutor = false,
  showWhiteboard = false,
  showAnnotations = false,
  showChat = false,
  onToggleWhiteboard,
  onToggleAnnotations,
  onToggleChat,
}: CustomControlBarProps) {
  const { localParticipant } = useLocalParticipant();
  const room = useRoomContext();
  const router = useRouter();
  const [isScreenSharing, setIsScreenSharing] = useState(false);
  const [hasScreenShare, setHasScreenShare] = useState(false);
  const [isControlBarVisible, setIsControlBarVisible] = useState(true);
  const hideTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Sync with actual participant state
  const isMuted = localParticipant ? !localParticipant.isMicrophoneEnabled : true;
  const isCameraOff = localParticipant ? !localParticipant.isCameraEnabled : true;

  // Check if anyone (local or remote) is screen sharing
  useEffect(() => {
    if (!room || !localParticipant) return;

    const checkForScreenShare = () => {
      // Check local participant - use trackPublications Map directly
      let hasShare = false;
      
      // Check all local tracks including screen share
      const localScreenShare = localParticipant.getTrackPublication(Track.Source.ScreenShare);
      if (localScreenShare) {
        hasShare = true;
        console.log('ÔøΩÔ∏è Found local screen share track!');
      }

      // Also check videoTrackPublications
      if (!hasShare) {
        localParticipant.videoTrackPublications.forEach((pub) => {
          console.log('üìπ Local video publication:', { source: pub.source, trackName: pub.trackName });
          if (pub.source === Track.Source.ScreenShare) {
            hasShare = true;
          }
        });
      }

      // Check remote participants
      if (!hasShare) {
        room.remoteParticipants.forEach(participant => {
          const remoteScreenShare = participant.getTrackPublication(Track.Source.ScreenShare);
          if (remoteScreenShare) {
            hasShare = true;
            console.log(`üñ•Ô∏è Found remote screen share from ${participant.identity}!`);
          }
        });
      }

      console.log('üñ•Ô∏è Screen share detected:', hasShare);
      setHasScreenShare(hasShare);
      setIsScreenSharing(hasShare && localParticipant.getTrackPublication(Track.Source.ScreenShare) !== undefined);
    };

    // Check immediately
    checkForScreenShare();

    // Check with slight delay to ensure tracks are updated
    const timer = setTimeout(checkForScreenShare, 300);

    // Listen to track events
    const handleTrackPublished = (pub: any) => {
      console.log('üé¨ Track published:', { source: pub.source, kind: pub.kind });
      checkForScreenShare();
    };

    const handleTrackUnpublished = (pub: any) => {
      console.log('üé¨ Track unpublished:', { source: pub.source, kind: pub.kind });
      checkForScreenShare();
    };

    localParticipant.on('trackPublished', handleTrackPublished);
    localParticipant.on('trackUnpublished', handleTrackUnpublished);
    room.on('trackPublished', handleTrackPublished);
    room.on('trackUnpublished', handleTrackUnpublished);
    room.on('participantConnected', checkForScreenShare);
    room.on('participantDisconnected', checkForScreenShare);

    return () => {
      clearTimeout(timer);
      localParticipant.off('trackPublished', handleTrackPublished);
      localParticipant.off('trackUnpublished', handleTrackUnpublished);
      room.off('trackPublished', handleTrackPublished);
      room.off('trackUnpublished', handleTrackUnpublished);
      room.off('participantConnected', checkForScreenShare);
      room.off('participantDisconnected', checkForScreenShare);
    };
  }, [room, localParticipant]);

  // Debug: Log state changes
  useEffect(() => {
    console.log('üé® Button states:', { 
      hasScreenShare, 
      showAnnotations, 
      willBeGreen: hasScreenShare && !showAnnotations 
    });
  }, [hasScreenShare, showAnnotations]);

  // Auto-hide control bar after inactivity
  useEffect(() => {
    const showControlBar = () => {
      setIsControlBarVisible(true);
      
      // Clear existing timeout
      if (hideTimeoutRef.current) {
        clearTimeout(hideTimeoutRef.current);
      }
      
      // Hide after 3 seconds of inactivity
      hideTimeoutRef.current = setTimeout(() => {
        setIsControlBarVisible(false);
      }, 3000);
    };

    // Show control bar on mouse move
    const handleMouseMove = (e: MouseEvent) => {
      // Only show if mouse is in bottom 150px of screen
      const windowHeight = window.innerHeight;
      if (e.clientY > windowHeight - 150) {
        showControlBar();
      }
    };

    // Show control bar on any tap/click
    const handleClick = () => {
      showControlBar();
    };

    // Show control bar on touch (mobile)
    const handleTouchStart = () => {
      showControlBar();
    };

    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('click', handleClick);
    window.addEventListener('touchstart', handleTouchStart);

    // Initial show
    showControlBar();

    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('click', handleClick);
      window.removeEventListener('touchstart', handleTouchStart);
      if (hideTimeoutRef.current) {
        clearTimeout(hideTimeoutRef.current);
      }
    };
  }, []);

  // Removed duplicate useEffect for isScreenSharing - now handled above

  const toggleMicrophone = async () => {
    if (localParticipant) {
      const enabled = localParticipant.isMicrophoneEnabled;
      await localParticipant.setMicrophoneEnabled(!enabled);
    }
  };

  const toggleCamera = async () => {
    if (localParticipant) {
      const enabled = localParticipant.isCameraEnabled;
      await localParticipant.setCameraEnabled(!enabled);
    }
  };

  const toggleScreenShare = async () => {
    if (!localParticipant || !room) return;

    if (isScreenSharing) {
      console.log('üõë Stopping screen share...');
      
      // Get the screen share track publication
      const screenSharePub = localParticipant.getTrackPublication(Track.Source.ScreenShare);
      const screenAudioPub = localParticipant.getTrackPublication(Track.Source.ScreenShareAudio);
      
      // Stop and unpublish tracks
      if (screenSharePub?.track) {
        screenSharePub.track.stop();
        await localParticipant.unpublishTrack(screenSharePub.track);
        console.log('‚úÖ Screen share video track stopped and unpublished');
      }
      
      if (screenAudioPub?.track) {
        screenAudioPub.track.stop();
        await localParticipant.unpublishTrack(screenAudioPub.track);
        console.log('‚úÖ Screen share audio track stopped and unpublished');
      }
      
      // Update state
      setIsScreenSharing(false);
      setHasScreenShare(false);
      
      // Also call the built-in method as fallback
      await localParticipant.setScreenShareEnabled(false);
    } else {
      try {
        console.log('üñ•Ô∏è Requesting ULTRA quality screen share (up to 4K @ 60fps with VP9)...');
        
        // Manual high-quality capture with explicit constraints
        const stream = await navigator.mediaDevices.getDisplayMedia({
          video: {
            width: { ideal: 3840, max: 3840 },      // Request 4K
            height: { ideal: 2160, max: 2160 },     // Request 4K height
            frameRate: { ideal: 30, max: 60 },      // Up to 60fps
            // Important: request the full resolution without any restrictions
            aspectRatio: { ideal: 16/9 },           // Prefer widescreen but allow any
          },
          audio: true, // Capture system audio if available
          // Note: preferCurrentTab is removed - let user choose naturally
        } as any);
        
        console.log('‚úÖ Successfully obtained display media stream');

        // Get the video track
        const videoTrack = stream.getVideoTracks()[0];
        const audioTrack = stream.getAudioTracks()[0];

        if (videoTrack) {
          // CRITICAL: Set contentHint to "detail" for text sharpness
          if ('contentHint' in videoTrack) {
            (videoTrack as any).contentHint = 'detail';
            console.log('‚úÖ Set contentHint="detail" for ultra-sharp text');
          }

          const settings = videoTrack.getSettings();
          console.log(`‚úÖ Captured screen at: ${settings.width}x${settings.height} @ ${settings.frameRate}fps`);
          console.log('üìê Full track settings:', settings);
          console.log('üì∫ Track constraints:', videoTrack.getConstraints());

          // Detect if user selected a Chrome Tab (low quality)
          const isLowQuality = settings.height && settings.height < 900;
          const displaySurface = (settings as any).displaySurface; // 'monitor', 'window', or 'browser'
          
          if (displaySurface === 'browser' || isLowQuality) {
            console.warn('‚ö†Ô∏è LOW QUALITY TAB SHARING DETECTED!');
            console.warn(`   Display Surface: ${displaySurface}`);
            console.warn(`   Resolution: ${settings.width}x${settings.height}`);
            
            // Stop the stream immediately - we'll let user try again with better option
            stream.getTracks().forEach(track => track.stop());
            console.log('üõë Stopped low-quality tab share stream');
            
            // Show informative message and guide user to reshare
            alert(`‚ùå Tab Sharing Not Supported

Chrome Tab sharing provides very low quality (${settings.width}x${settings.height}) which will be blurry for students.

‚úÖ Please click the screen share button again and select:
   ‚Ä¢ "Entire Screen" - Best quality + audio support
   ‚Ä¢ "Window" - Good quality

üí° Tip: Look for the tabs at the top of Chrome's share picker:
   [Entire Screen] [Window] [Chrome Tab]
   
Select "Entire Screen" or "Window" instead of "Chrome Tab".`);
            
            console.log('ÔøΩ User needs to reshare with Entire Screen or Window');
            return;
          }

          // Publish the screen share track manually with LiveKit
          console.log('üì§ Publishing screen share track to LiveKit...', {
            trackId: videoTrack.id,
            trackLabel: videoTrack.label,
            readyState: videoTrack.readyState,
            muted: videoTrack.muted,
            enabled: videoTrack.enabled,
          });

          try {
            await localParticipant.publishTrack(videoTrack, {
              name: 'screen_share',
              source: Track.Source.ScreenShare,
              // These settings prevent quality pulsing/drops
              simulcast: false,           // CRITICAL: No quality layers
              videoCodec: 'vp9',          // Best quality codec
              // CRITICAL: Force high bitrate, no adaptive reduction
              videoEncoding: {
                maxBitrate: 10_000_000,   // 10 Mbps constant
                maxFramerate: 60,          // 60fps
              },
            });
            console.log('‚úÖ Screen share track successfully published!');
          } catch (publishError) {
            console.error('‚ùå Failed to publish screen share track:', publishError);
            // Stop the stream since we couldn't publish it
            stream.getTracks().forEach(track => track.stop());
            throw publishError;
          }

          console.log('‚úÖ Screen share published with ULTRA settings:');
          console.log('   ‚Ä¢ Resolution:', `${settings.width}x${settings.height}`);
          console.log('   ‚Ä¢ Frame Rate:', `${settings.frameRate}fps`);
          console.log('   ‚Ä¢ Bitrate: 10 Mbps (gaming-level quality)');
          console.log('   ‚Ä¢ Codec: VP9 (superior compression)');
          console.log('   ‚Ä¢ Content Hint: DETAIL (optimized for text)');
          console.log('   ‚Ä¢ Simulcast: DISABLED (no quality drops)');
          console.log('   ‚Ä¢ Adaptive: DISABLED (constant quality)');
          
          // CRITICAL: Immediately update state after publishing
          setIsScreenSharing(true);
          setHasScreenShare(true);
        }

        // Publish screen audio if available
        if (audioTrack) {
          await localParticipant.publishTrack(audioTrack, {
            name: 'screen_share_audio',
            source: Track.Source.ScreenShareAudio,
          });
          console.log('‚úÖ Screen audio published');
          console.log('üîä System audio is being shared!');
        } else {
          console.log('‚ö†Ô∏è No audio track captured');
          console.log('üí° To share audio:');
          console.log('   1. Make sure you checked "Share audio" in the browser picker');
          console.log('   2. Use Chrome browser (best audio support)');
          console.log('   3. Share a Chrome Tab (has "Share tab audio" option)');
        }

        // Handle track ending (user stops sharing via browser UI)
        videoTrack.addEventListener('ended', () => {
          console.log('üõë Screen share stopped by user');
          setIsScreenSharing(false);
          setHasScreenShare(false);
          localParticipant.setScreenShareEnabled(false);
        });
        
      } catch (error) {
        console.error('‚ùå Screen share failed:', error);
        
        // Check if user cancelled the picker
        if (error instanceof DOMException && error.name === 'NotAllowedError') {
          console.log('‚ÑπÔ∏è User cancelled screen share picker');
          return; // Silent return, no error message needed
        }
        
        // Check if user dismissed without selecting
        if (error instanceof DOMException && error.name === 'AbortError') {
          console.log('‚ÑπÔ∏è User aborted screen share');
          return; // Silent return, no error message needed
        }
        
        // For other errors, try fallback
        try {
          console.log('‚ö†Ô∏è Falling back to simplified screen share...');
          await localParticipant.setScreenShareEnabled(true, { audio: true });
          console.log('‚úÖ Screen share enabled with fallback method');
          setIsScreenSharing(true);
          setHasScreenShare(true);
        } catch (fallbackError) {
          console.error('‚ùå All screen share attempts failed:', fallbackError);
          alert(`Screen sharing failed. Please try:
1. Refresh the page
2. Check browser permissions
3. Try a different browser (Chrome works best)

üí° TIP: When sharing, select "Entire Screen" or "Window" 
instead of "Chrome Tab" for best quality!`);
        }
      }
    }
  };

  const handleLeave = async () => {
    await room.disconnect();
    router.push('/');
  };

  const GlassButton = ({
    onClick,
    active = false,
    danger = false,
    success = false,
    children,
    title,
  }: {
    onClick: () => void;
    active?: boolean;
    danger?: boolean;
    success?: boolean;
    children: React.ReactNode;
    title: string;
  }) => (
    <button
      onClick={onClick}
      title={title}
      className={cn(
        "group relative p-4 rounded-xl transition-all duration-200",
        "bg-white/10 backdrop-blur-md border border-white/20",
        "hover:bg-white/20 hover:border-white/30 hover:-translate-y-0.5 hover:scale-110",
        "active:translate-y-0 active:scale-95",  // Better touch feedback
        // Larger touch target for mobile
        "min-w-[48px] min-h-[48px] flex items-center justify-center",
        // Touch-friendly spacing
        "touch-manipulation select-none",
        danger && "bg-red-500/20 border-red-400/30 hover:bg-red-500/30",
        success && "bg-green-500/50 border-green-400/60 hover:bg-green-500/60 shadow-lg shadow-green-500/30",
        active && !success && "bg-white/25 border-white/40"
      )}
    >
      <div className={cn("text-white transition-transform")}>
        {children}
      </div>
    </button>
  );

  return (
    <div 
      className={cn(
        "fixed bottom-4 left-1/2 -translate-x-1/2 transition-all duration-300",
        // Increase z-index when annotations are active to stay above canvas (z-50) and toolbar (z-60)
        showAnnotations ? "z-[61]" : "z-20",
        // Mobile: full width with padding, Desktop: auto width
        "w-full max-w-[95vw] md:max-w-none md:w-auto px-2 md:px-0",
        isControlBarVisible ? "opacity-100 translate-y-0" : "opacity-0 translate-y-16 pointer-events-none"
      )}
    >
      <div className={cn(
        "flex items-center gap-2 md:gap-3 px-4 md:px-6 py-3 md:py-4",
        "rounded-2xl bg-black/20 backdrop-blur-xl border border-white/10 shadow-2xl",
        // Make it scrollable on very small screens
        "overflow-x-auto overflow-y-hidden scrollbar-hide",
        // Smooth scrolling on mobile
        "snap-x snap-mandatory"
      )}>
        {/* Basic controls - always visible */}
        <GlassButton
          onClick={toggleMicrophone}
          active={!isMuted}
          title={isMuted ? "Unmute" : "Mute"}
        >
          {isMuted ? <MicOff className="w-5 h-5" /> : <Mic className="w-5 h-5" />}
        </GlassButton>

        <GlassButton
          onClick={toggleCamera}
          active={!isCameraOff}
          title={isCameraOff ? "Turn Camera On" : "Turn Camera Off"}
        >
          {isCameraOff ? <VideoOff className="w-5 h-5" /> : <Video className="w-5 h-5" />}
        </GlassButton>

        <GlassButton
          onClick={toggleScreenShare}
          active={isScreenSharing}
          title={isScreenSharing ? "Stop Sharing Screen" : "Share Screen"}
        >
          <Monitor className="w-5 h-5" />
        </GlassButton>

        <div className="w-px h-10 bg-white/20 mx-2" />

        {/* Chat Button - Available to everyone */}
        {onToggleChat && (
          <GlassButton
            onClick={onToggleChat}
            active={showChat}
            title={showChat ? "Close Chat" : "Open Chat"}
          >
            <MessageSquare className="w-5 h-5" />
          </GlassButton>
        )}

        {/* Tutor-only controls */}
        {isTutor && (
          <>
            <div className="w-px h-10 bg-white/20 mx-2" />
            
            {!showWhiteboard && onToggleAnnotations && (
              <>
                {console.log('üî¥ Rendering annotate button with:', { hasScreenShare, showAnnotations, success: hasScreenShare })}
                <GlassButton
                  onClick={onToggleAnnotations}
                  active={showAnnotations}
                  success={hasScreenShare}
                  title={showAnnotations ? "Hide Annotations" : "Annotate Screen"}
                >
                  <Pencil className="w-5 h-5" />
                </GlassButton>
              </>
            )}

            {onToggleWhiteboard && (
              <GlassButton
                onClick={onToggleWhiteboard}
                active={showWhiteboard}
                title={showWhiteboard ? "Show Video" : "Open Whiteboard"}
              >
                <Square className="w-5 h-5" />
              </GlassButton>
            )}
          </>
        )}

        <div className="w-px h-10 bg-white/20 mx-2" />

        <GlassButton onClick={handleLeave} danger title="Leave Session">
          <PhoneOff className="w-5 h-5" />
        </GlassButton>
      </div>
    </div>
  );
}
